## 1. 什么是变量？

变量能读能写，能变就必定在内存里

指针保存的是地址，32位处理器中地址都是32为的，无论什么类型的指针变量都是4字节

### 局部变量

栈的基地址是程序员设置的，局部变量在栈分配，通过栈针地址向下移动，局部变量在运行中由cpu指令写值

### 全局变量及局部静态变量

局部静态变量和全局变量的地址是链接器决定的，存储在二进制文件中；局部静态变量及全局变量在编译时期初始化
有初始值的全局变量和静态变量初始化为初始值（由程序的data段拷贝过去），无初始值的或初始值为0的初始化为0（放在ZI段，类似memset函数把ZI段全部清零，然后再去执行main函数）。全局变量和静态变量可以在运行时整段一起拷进内存里（汇编里的重定位）。

## 2. 函数是什么？

- 函数是一系列的机器码
- 调用函数：让cpu的PC寄存器等于一系列机器码的首地址

## 3. 指针是什么？

- 指针变量，也是一个变量，存放的是“首地址”
- 使用指针的本质：跟变量的访问做对比

### 结构体指针、函数指针

结构体不能嵌套自己类型的结构体（因为无法确定该结构体的大小，因为无限嵌套），但是可以嵌套自己的结构体指针（指针大小为4）。

结构体中的数据成员就相当于c++中类的成员，函数指针就相当于c++中的成员函数。
函数指针变量：`void (*func)(int);`  func是一个变量，一个函数指针变量
`typedef int (*add_type)(int, int);`这是把`int (*)(int, int)`函数指针类型定义了一个别名add_type
以后就可以用add_type func1;来定义函数指针变量了
不用别名就需要int (*func1) (int, int);

## 4. 几个关键字

### Volatile

1. 防止编译器优化，比如变量无用的中间值
2. 确保每次对变量的操作都从内存操作

### const

Const修饰的是常量（不可修改），可以放到flash里，可以不放在内存而节省内存

### static

当两个.c文件都定义了一个名字相同的全局变量比如a，编译时会发生重定义错误，如果变量前加上static，表示当前变量的作用域仅仅是是当前文件`static int a;`

### extern

`extern int a;`表示这个a变量是在另一个文件内定义的



## 引入结构体、结构体赋值

```c
// 32位处理器情况下
struct person {
	char *name;
	int age;
}; //分配两个8字节
struct person {
	char name[100];
	int age;
}; //分配104个字节
struct person {
    char a;
    char b;
    int age;
}; // 分配8个字节，实际只用了6个
struct person{
    char a;
    int age;
}; // 分配8字节，实际只用了5个。 但是写的时候都是按4个字节写入

int main {
    struct person luoyi = {'A', 'B', 10};
    int *p;
    p = (int *)&luoyi.a;
    *p = 'C';   // 会破环luoyi.b
    return 0;
}
```

